
{{ $resourceSDKStructName := printf "%s.%s" .resourceSDKName .EntryOrConfig }}
{{ $resourceTFStructName := printf "%s%sObject" .structName .ListAttribute.CamelCase }}

var state, plan {{ .structName }}Model
resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
if resp.Diagnostics.HasError() {
	return
}

// Basic logging.
tflog.Info(ctx, "performing resource create", map[string]any{
	"resource_name": "panos_{{ UnderscoreName .structName }}",
	"function":      "Create",
})

{{ RenderEncryptedValuesInitialization }}

var location {{ .resourceSDKName }}.Location
{{ RenderLocationsStateToPango "plan.Location" "location" }}

// Basic logging.
tflog.Info(ctx, "performing resource update", map[string]any{
	"resource_name": "panos_{{ UnderscoreName .structName }}",
	"function":      "Update",
})

{{ if eq .PluralType "map" }}
var elements map[string]{{ $resourceTFStructName }}
resp.Diagnostics.Append(state.{{ .ListAttribute.CamelCase }}.ElementsAs(ctx, &elements, false)...)
if resp.Diagnostics.HasError() {
	return
}

stateEntries := make([]*{{ $resourceSDKStructName }}, len(elements))
idx := 0
for name, elt := range elements {
	var entry *{{ .resourceSDKName }}.{{ .EntryOrConfig }}
	resp.Diagnostics.Append(elt.CopyToPango(ctx, o.client, nil, &entry, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}
	entry.Name = name
	stateEntries[idx] = entry
	idx++
}
{{ else if or (eq .PluralType "list") (eq .PluralType "set") }}
var elements []{{ $resourceTFStructName }}
resp.Diagnostics.Append(state.{{ .ListAttribute.CamelCase }}.ElementsAs(ctx, &elements, false)...)
if resp.Diagnostics.HasError() {
	return
}

stateEntries := make([]*{{ $resourceSDKStructName }}, len(elements))
for idx, elt := range elements {
	var entry *{{ $resourceSDKStructName }}
	resp.Diagnostics.Append(elt.CopyToPango(ctx, o.client, nil, &entry, ev)...)
	if resp.Diagnostics.HasError() {
		 return
	}
	stateEntries[idx] = entry
}
{{- end }}

stateEntriesByName := make(map[string]*{{ $resourceSDKStructName }}, len(stateEntries))
for _, elt := range stateEntries {
	stateEntriesByName[elt.Name] = elt
}

components, err := state.resourceXpathParentComponents()
if err != nil {
	resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
	return
}

existing, err := o.manager.ReadMany(ctx, location, components)
if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
	resp.Diagnostics.AddError("Error while reading entries from the server", err.Error())
	return
}

filtered := make([]*{{ $resourceSDKStructName }}, 0, len(stateEntries))
for _, elt := range existing {
	if _, found := stateEntriesByName[elt.EntryName()]; found {
		filtered = append(filtered, elt)
	}
}

existingEntriesByName := make(map[string]*{{ $resourceSDKStructName }}, len(filtered))
for _, elt := range filtered {
	existingEntriesByName[elt.Name] = elt
}

resp.Diagnostics.Append(plan.{{ .ListAttribute.CamelCase }}.ElementsAs(ctx, &elements, false)...)
if resp.Diagnostics.HasError() {
	return
}

{{ if eq .PluralType "map" }}
planEntries := make([]*{{ $resourceSDKStructName }}, len(elements))
idx = 0
for name, elt := range elements {
	entry, _ := existingEntriesByName[name]
	resp.Diagnostics.Append(elt.CopyToPango(ctx, o.client, nil, &entry, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	entry.Name = name
	planEntries[idx] = entry
	idx++
}
{{ else if or (eq .PluralType "list") (eq .PluralType "set") }}
var planEntries []*{{ $resourceSDKStructName }}
for _, elt := range elements {
	existingEntry, _ := existingEntriesByName[elt.Name.ValueString()]
	resp.Diagnostics.Append(elt.CopyToPango(ctx, o.client, nil, &existingEntry, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	planEntries = append(planEntries, existingEntry)
}
{{- end }}

processed, err := o.manager.UpdateMany(ctx, location, components, stateEntries, planEntries)
if err != nil {
	resp.Diagnostics.AddError("Error while updating entries", err.Error())
	return
}

{{- if eq .PluralType "map" }}
objects := make(map[string]*{{ $resourceTFStructName }}, len(processed))
for _, elt := range processed {
	var object {{ $resourceTFStructName }}
	object.name = elt.Name
	copy_diags := object.CopyFromPango(ctx, o.client, nil, elt, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	objects[elt.Name] = &object
}
{{- else if or (eq .PluralType "list") (eq .PluralType "set") }}
objects := make([]*{{ $resourceTFStructName }}, len(processed))
for idx, elt := range processed {
	var object {{ $resourceTFStructName }}
	resp.Diagnostics.Append(object.CopyFromPango(ctx, o.client, nil, elt, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	objects[idx] = &object
}
{{- end }}

var list_diags diag.Diagnostics
{{ if eq .PluralType "map" }}
plan.{{ .ListAttribute.CamelCase }}, list_diags = types.MapValueFrom(ctx, state.getTypeFor("{{ .ListAttribute.Underscore }}"), objects)
{{ else if eq .PluralType "list" }}
plan.{{ .ListAttribute.CamelCase }}, list_diags = types.ListValueFrom(ctx, state.getTypeFor("{{ .ListAttribute.Underscore }}"), objects)
{{ else if eq .PluralType "set" }}
plan.{{ .ListAttribute.CamelCase }}, list_diags = types.SetValueFrom(ctx, state.getTypeFor("{{ .ListAttribute.Underscore }}"), objects)
{{- end }}
resp.Diagnostics.Append(list_diags...)
if resp.Diagnostics.HasError() {
	return
}

{{ RenderEncryptedValuesFinalizer }}

resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
