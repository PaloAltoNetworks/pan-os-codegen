// We only manage a subset of PAN-OS object on the given list, so care
// has to be taken to calculate the order of those managed elements on the
// PAN-OS side.

// We filter all existing entries to end up with a list of entries that
// are in the plan. For every element of that list, we store its PAN-OS
// list index as StateIdx. Finally, the managedEntries index will serve
// as a way to check if managed entries are in order relative to each
// other.
var movementRequired bool
managedEntriesByName := make(map[string]*entryWithState, len(planEntriesByName))
idx := 0
for existingIdx, elt := range existing {
	if planEntry, found := planEntriesByName[elt.Name]; found {
		managedEntriesByName[elt.Name] = &entryWithState{
			Entry: existing[existingIdx],
			StateIdx: idx,
		}
		planEntry.Entry.Uuid = elt.Uuid
		planEntriesByName[elt.Name] = planEntry
	}
	idx++
}

// First, we check if managedEntries order matches planEntriesByName to check
// if all entries from the plan are properly ordered on the server.
var previousManagedEntry, previousPlannedEntry *entryWithState
for _, elt := range managedEntriesByName {
	// plannedEntriesByName is a map of entries from the plan indexed by their
	// name. If idx doesn't match StateIdx of the entry from the plan, the PAN-OS
	// object is out of order.
	plannedEntry := planEntriesByName[elt.Entry.Name]
	if plannedEntry.StateIdx != elt.StateIdx {
		movementRequired = true
		break
	}
	// If this is the first element we are comparing, store it for future reference
	// and continue. We will use it to calculate distance between two elements in
	// PAN-OS list.
	if previousManagedEntry == nil {
		previousManagedEntry = elt
		previousPlannedEntry = plannedEntry
		continue
	}

	serverDistance := elt.StateIdx - previousManagedEntry.StateIdx
	planDistance := plannedEntry.StateIdx - previousPlannedEntry.StateIdx

	// If the distance between previous and current object differs between
	// PAN-OS and the plan, we need to move objects around.
	if serverDistance != planDistance {
		movementRequired = true
		break
	}

	previousManagedEntry = elt
	previousPlannedEntry = plannedEntry
}

// If all entries are ordered properly, we check if their position matches what's
// requested.
if !movementRequired {
	existingEntriesByName := make(map[string]*entryWithState, len(existing))
	for idx, elt := range existing {
		existingEntriesByName[elt.Name] = &entryWithState{
			Entry: existing[idx],
			StateIdx: idx,
		}
	}

	positionWhere := {{ .State }}.Position.Where.ValueString()
	switch positionWhere {
	case "first":
		if existing[len({{ .Entries }})-1].Name != {{ .Entries }}[len({{ .Entries }})-1].Name {
			movementRequired = true

		}
	case "last":
		if existing[len({{ .Entries }})-1].Name != {{ .Entries }}[len({{ .Entries }})-1].Name {
			movementRequired = true
		}
	case "before":
		pivot := {{ .State }}.Position.Pivot.ValueString()
		directly := {{ .State }}.Position.Directly.ValueBool()
		if existingPivot, found := existingEntriesByName[pivot]; !found {
			resp.Diagnostics.AddError("failed to create move actions", fmt.Sprintf("pivot point '%s' missing from the server", pivot))
		} else if directly {
			if existingPivot.StateIdx == 0 {
				movementRequired = true
			} else if existing[existingPivot.StateIdx-1].Name != {{ .Entries }}[len({{ .Entries }})-1].Name {
				movementRequired = true
			}
		} else {
			if existingPivot.StateIdx == 0 {
				movementRequired = true
			}
		}
	case "after":
		pivot := {{ .State }}.Position.Pivot.ValueString()
		directly := {{ .State }}.Position.Directly.ValueBool()
		if existingPivot, found := existingEntriesByName[pivot]; !found {
			resp.Diagnostics.AddError("failed to create move actions", fmt.Sprintf("pivot point '%s' missing from the server", pivot))
		} else if directly {
			if existingPivot.StateIdx == len(existing)-1 {
				movementRequired = true
			} else if existing[existingPivot.StateIdx+1].Name != {{ .Entries }}[0].Name {
				movementRequired = true
			}
		} else {
			if existingPivot.StateIdx == len(existing)-1 {
				movementRequired = true
			}
		}
	}
}
