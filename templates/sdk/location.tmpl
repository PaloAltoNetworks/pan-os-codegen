package {{packageName .GoSdkPath}}

{{- if $.Imports}}
  {{ renderImports "location" "imports"}}
{{- else }}
  {{ renderImports "location"}}
{{- end }}

{{ RenderEntryImportStructs }}

type Location struct {
{{range $location := .OrderedLocations}}
    {{- $location.Name.CamelCase }} {{locationType $location true}} `json:"{{$location.Name.Underscore}}{{omitEmpty $location}}"`
{{end}}
}
{{range $location := .OrderedLocations}}
    {{- if $location.Vars}}
        type {{locationType $location false}} struct {
        {{- range $key, $var := $location.Vars}}
            {{$var.Name.CamelCase}} string `json:"{{$var.Name.Underscore}}"`
        {{- end}}
        }
    {{end}}
{{- end}}

{{range $location := .OrderedLocations}}
    {{- if $location.Vars}}
        func New{{locationType $location false}}() *Location {
            return &Location{
                {{- $location.Name.CamelCase}}: &{{locationType $location false}}{
                {{- range $key, $var := $location.Vars}}
                    {{$var.Name.CamelCase}}: "{{$var.Default}}",
                {{- end}}
                },
            }
        }
    {{- else}}
        {{- if eq $location.Name.CamelCase "Shared"}}
        func NewSharedLocation() *Location {
            return &Location{
                Shared: true,
            }
        }
        {{- end}}
    {{- end}}
{{- end}}

func (o Location) IsValid() error {
count := 0

switch {
{{- range $location := .OrderedLocations}}
    case o.{{- $location.Name.CamelCase}}{{if ne (locationType $location true) "bool"}} != nil{{end}}:
    {{- range $name, $var := $location.Vars}}
        if o.{{$location.Name.CamelCase}}.{{$var.Name.CamelCase}} == "" {
        return fmt.Errorf("{{$var.Name.CamelCase}} is unspecified")
        }
    {{- end}}
    count++
{{- end}}
}

if count == 0 {
return fmt.Errorf("no path specified")
}

if count > 1 {
return fmt.Errorf("multiple paths specified: only one should be specified")
}

return nil
}

func (o Location) XpathPrefix(vn version.Number) ([]string, error) {

var ans []string

switch {
{{- range $location := .OrderedLocations}}
    case o.{{- $location.Name.CamelCase}}{{if ne (locationType $location true) "bool"}} != nil{{end}}:
    {{- range $name, $var := $location.Vars}}
        if o.{{$location.Name.CamelCase}}.{{$var.Name.CamelCase}} == "" {
        return nil, fmt.Errorf("{{$var.Name.CamelCase}} is unspecified")
        }
    {{- end}}
    ans = []string{
    {{- range $name, $xpath := $location.Xpath}}
        {{- if contains $xpath "Entry"}}
            {{generateEntryXpath "util.AsEntryXpath([]string{" "})" $location.Name.CamelCase $xpath}}
        {{- else if contains $xpath "Object"}}
            {{generateEntryXpath "" "" $location.Name.CamelCase $xpath}}
        {{- else}}
            "{{$xpath}}",
        {{- end}}
    {{- end}}
    }
{{- end}}
default:
return nil, errors.NoLocationSpecifiedError
}

return ans, nil
}

{{- if .Entry}}
    func (o Location) XpathWithEntryName(vn version.Number, name string) ([]string, error) {
{{- else}}
    func (o Location) Xpath(vn version.Number) ([]string, error) {
{{- end}}

ans, err := o.XpathPrefix(vn)
if err != nil {
return nil, err
}

{{- if .Entry}}
    ans = append(ans, Suffix...)
    ans = append(ans, util.AsEntryXpath([]string{name}))
{{- end}}

return ans, nil
}

{{- if .Entry}}
    func (o Location) XpathWithUuid(vn version.Number, uuid string) ([]string, error) {

    ans, err := o.XpathPrefix(vn)
    if err != nil {
    return nil, err
    }
    ans = append(ans, Suffix...)
    ans = append(ans, util.AsUuidXpath(uuid))

    return ans, nil
    }
{{- end}}
