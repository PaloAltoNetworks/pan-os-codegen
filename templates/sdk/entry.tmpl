{{- if .Entry}}
package {{packageName .GoSdkPath}}

import (
	"encoding/xml"
	"fmt"

	"github.com/PaloAltoNetworks/pango/filtering"
	"github.com/PaloAltoNetworks/pango/generic"
	"github.com/PaloAltoNetworks/pango/util"
	"github.com/PaloAltoNetworks/pango/version"
)

var (
	_ filtering.Fielder = &Entry{}
)

var (
	Suffix = []string{
	{{- $length := subtract (len .XpathSuffix) 1 }}
	{{- range $index, $suffix := .XpathSuffix}}"
	    {{- $suffix}}"{{- if lt $index $length}},{{- end}}
	{{- end}}}
)

type Entry struct {
    Name string
    {{- range $_, $param := .Spec.Params}}
    {{$param.Name.CamelCase}} {{specParamType "" $param}}
    {{- end}}
    {{- range $_, $param := .Spec.OneOf}}
    {{$param.Name.CamelCase}} {{specParamType "" $param}}
    {{- end}}

	Misc map[string][]generic.Xml
}

{{- range $name, $spec := nestedSpecs .Spec }}
type Spec{{$name}} struct {
    {{- range $_, $param := $spec.Params}}
    {{$param.Name.CamelCase}} {{specParamType $name $param}}
    {{- end}}
    {{- range $_, $param := $spec.OneOf}}
    {{$param.Name.CamelCase}} {{specParamType $name $param}}
    {{- end}}

    Misc map[string][]generic.Xml
}
{{- end}}

type EntryXmlContainer struct {
	Answer []EntryXml `xml:"entry"`
}

type EntryXml struct {
	XMLName xml.Name `xml:"entry"`
	Name string `xml:"name,attr"`
    {{- range $_, $param := .Spec.Params}}
    {{$param.Name.CamelCase}} {{xmlParamType "" $param}} {{xmlTag $param}}
    {{- end}}
    {{- range $_, $param := .Spec.OneOf}}
    {{$param.Name.CamelCase}} {{xmlParamType "" $param}} {{xmlTag $param}}
    {{- end}}

	Misc []generic.Xml `xml:",any"`
}

{{- range $name, $spec := nestedSpecs .Spec }}
type Spec{{$name}}Xml struct {
    {{- range $_, $param := $spec.Params}}
    {{$param.Name.CamelCase}} {{xmlParamType $name $param}} {{xmlTag $param}}
    {{- end}}
    {{- range $_, $param := $spec.OneOf}}
    {{$param.Name.CamelCase}} {{xmlParamType $name $param}} {{xmlTag $param}}
    {{- end}}

    Misc []generic.Xml `xml:",any"`
}
{{- end}}

func (e *Entry) CopyMiscFrom(v *Entry) {
	if v == nil || len(v.Misc) == 0 {
		return
	}

	e.Misc = make(map[string][]generic.Xml)
	for key := range v.Misc {
		e.Misc[key] = append([]generic.Xml(nil), v.Misc[key]...)
	}
}

func (e *Entry) Field(v string) (any, error) {
	if v == "name" || v == "Name" {
		return e.Name, nil
	}

    {{- range $_, $param := .Spec.Params}}
    if v == "{{$param.Name.Underscore}}" || v == "{{$param.Name.CamelCase}}" {
        return e.{{$param.Name.CamelCase}}, nil
    }
    {{- if eq $param.Type "list"}}
	if v == "{{$param.Name.Underscore}}|LENGTH" || v == "{{$param.Name.CamelCase}}|LENGTH" {
        return int64(len(e.{{$param.Name.CamelCase}})), nil
    }
    {{- end}}
    {{- end}}
    {{- range $_, $param := .Spec.OneOf}}
    if v == "{{$param.Name.Underscore}}" || v == "{{$param.Name.CamelCase}}" {
        return e.{{$param.Name.CamelCase}}, nil
    }
    {{- end}}

	return nil, fmt.Errorf("unknown field")
}

func Versioning(vn version.Number) (Specifier, Normalizer, error) {
	return SpecifyEntry, &EntryXmlContainer{}, nil
}

// TODO: think if struct EntryXml1 / E_0_0 has to be public or not ???
// maybe it's good to make it hidden and do not have in public documentation ...

func SpecifyEntry(o Entry) (any, error) {
	entry := EntryXml{}

	entry.Name = o.Name
    {{- range $_, $param := .Spec.Params}}
    {{specifyEntryAssignment "entry" $param}}
    {{- end}}
    {{- range $_, $param := .Spec.OneOf}}
    {{specifyEntryAssignment "entry" $param}}
    {{- end}}

	entry.Misc = o.Misc["Entry"]

	return entry, nil
}

func (c *EntryXmlContainer) Normalize() ([]Entry, error) {
	entryList := make([]Entry, 0, len(c.Answer))
	for _, o := range c.Answer {
		entry := Entry{
			Misc: make(map[string][]generic.Xml),
		}
		entry.Name = o.Name
        {{- range $_, $param := .Spec.Params}}
        {{normalizeAssignment "entry" $param}}
        {{- end}}
        {{- range $_, $param := .Spec.OneOf}}
        {{normalizeAssignment "entry" $param}}
        {{- end}}

		entry.Misc["Entry"] = o.Misc

		// TODO: start thinking about versioning e.g:
		// 1 approach: EntryXml1, EntryXml2, EntryXml3, ...
		// 2 approach: EntryXml_10_0_0, EntryXml_10_1_0, EntryXml_11_0_0, ...

		entryList = append(entryList, entry)
	}

	return entryList, nil
}

func SpecMatches(a, b *Entry) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}

	// Don't compare Name.
    {{- range $_, $param := .Spec.Params}}
    {{- if or (eq $param.Type "list") (eq $param.Type "string")}}
    if !util.{{specMatchesFunction $param}}(a.{{$param.Name.CamelCase}}, b.{{$param.Name.CamelCase}}) {
        return false
    }
    {{- end}}
    {{- end}}
    {{- range $_, $param := .Spec.OneOf}}
    {{- if or (eq $param.Type "list") (eq $param.Type "string")}}
    if !util.{{specMatchesFunction $param}}(a.{{$param.Name.CamelCase}}, b.{{$param.Name.CamelCase}}) {
        return false
    }
    {{- end}}
    {{- end}}

	return true
}
{{- end}}